<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[OCR手写识别_NoTe1]]></title>
    <url>%2F2019%2F11%2F07%2FOCR%E6%89%8B%E5%86%99%E8%AF%86%E5%88%AB-NoTe1%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>OCR手写识别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS231n-note-5]]></title>
    <url>%2F2019%2F11%2F05%2FCS231n-note-5%2F</url>
    <content type="text"><![CDATA[图像识别和分割分割语义分割只将像素进行分割并贴上对应的分类标签。Idea-1sliding windows，利用滑动窗口来对个像素进行分类，计算量太大idea-2全连接卷积神经网络，可以生成一个CxHxW的张量，对每个像素进行评分，数据集获取昂贵且困难。并且模型训练代价很高。idea-3不采用全连接(同尺寸)卷积神经网络，而是采用downsampling和upsampling，在中间层可以用池化或者跨卷积来降低清晰度，但是可以让网络建立的很深。upsampling去池化(Unpooling)Max Unpooling将池化层和去池化层相对应，其最大元素的相应位置将会被记录。转置卷积正常卷积和跨卷积(可以进行downsampling)并且可以学习参数进行下采样转置卷积在进行转置卷积时，将每个元素(标量)乘以过滤器(卷积核)，然后将加权后的卷积核叠加于新的输出。sample：卷积矩阵化$44input &lt;—&gt; 44output$$44input &lt;—&gt;22output$分类和定位定位一般使用回归损失函数。识别固定几类对象，再输入图片之后将识别图中对象框起来并预测该对象的从属类别。输入图片的包含对象数量是不确定的。候选区域方法(Region Proposals)将输入的图像划分为若干(很多)区域，在应用卷积神经网络对其进行分类。R-CNN 效率低Fast R-CNN 不用事先确定候选区而是通过一个卷积神经网络生成特征映射，在特征映射上通过固定函数像素划分确定候选区Faster R-CNN在确定备选区时自己进行区域选择网络的训练Detection without ProposalsYOLO(You Only Look Once)/SSD(Single Shot Detection)利用回归，将输入图片划分为网格。 然后预测每个基本的方框的类别权重以及距离对象的信息。目标分割两个分支，一个分支进行分类，一个分支进行类似语义分割确定对象的区域。DeepDream&amp;Feature InversionDeepDream：放大存在的特征Feature Inversion：特征反演纹理拼接&amp;风格迁移Gram Matrix传统风格迁移会消耗大量的资源Fast Style Transfer可视化和理解卷积神经网络]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS231n-note-4]]></title>
    <url>%2F2019%2F10%2F28%2FCS231n-note-4%2F</url>
    <content type="text"><![CDATA[深度学习软件PyTorch(TODO)组成(三层)Tensor运行在GPU上的命令式数组(Imperative ndarray)Variable计算图中的节点，存储数据和梯度Module一个神经网络的层CNN架构AlexNet：8layersZFNet：在AlexNet基础上调整了超参数VGG：16/19layers(全部采用3X3的卷积核——更有利于加深神经网络的深度)GoogleNet:22layers，高效的“Inception”层，无全连接层Inception层是设计好的一个局部网络拓朴，对输入的层进行并行操作，然后将每个滤波器的输出进行深度上的串联，通过0填充保持输出尺寸一致。利用1X1卷积核进行深度的压缩对模型进行改进。ResNet: 152layersResNet的整体结构RNNVanilla RNNh_t = f_w(h_{t-1},x_t)\\ h_t = tanh(W_{hh}h_{t-1}+W_{xh}x_t)\\ y_t = W_{hy}h_tLoss是每一个时步下的loss之和W的梯度是每个节点的W梯度值和Vanilla RNN梯度流在计算h0梯度时会发生梯度爆炸或者梯度消失当梯度爆炸，L2范式大于一个阙值时可以进行剪枝。123grad_norm = np.sum(grad * grad)if grad_norm &gt; threshold grad *= (threshold / grad_norm)当梯度消失时可以采用更深的RNN网络，比如LSTM。LSTM(长短期记忆网络)ht为隐藏状态，ct为单元状态，保留在lstm内部不会暴露到外面。LSTM状态变化图利用加法和乘法门可以很好的解决梯度消失和梯度爆炸问题。图像标注]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS231n-note-3]]></title>
    <url>%2F2019%2F10%2F21%2FCS231n-note-3%2F</url>
    <content type="text"><![CDATA[卷积神经网络卷积核($w$)通常遍历输入向量的所有通道，Input为32 X 32 X 3。卷积核在输入的向量上滑动，至于图像的一个局部区域发生关联，进行点积运算$w^Tx+b $ $w为filter$卷积核滑动在图像空间滑动，计算出每个位置的点积(滑动的方式可以改变)激活映射PS7X7X3 input(spatially)assume 3X3X3 filter可以得到一个5X5X1的output有多少个卷积核则Output的深度为多少。步长(stride)控制滑动的步长可以得到不同的output。如果stride=3则无法fitinput的纬度，则不采用。Output size：$(N-F) / stride + 1$可以增加像素(PS：补0)来改变输出的维度,保持输出维度和输入维度相同。Pooling layer将生成的表示更加小以及更易于控制，是参数更少。进行降采样(downsampling)，只在平面上进行降采样，不在深度上降采样。最大池化法(max pooling)池化层中也有一个卷积核(卷积核和步长使扫描区域不重合)，在滑动过程中不进行点积计算而是只取最大值。最大值可以反映在这个区域内神经元受激程度，所以最大池化法比均值池化法用的更多。一般在池化层不进行0像素填补Common settingsF = 2, S = 2F = 3, S = 3一般的卷积神经网络结构CONV + RELU + POOL + FC激活函数见note-2数据预处理一般对于图像，做零均值化的预处理(均值指所有输入图像的均值)均值减法（Mean subtraction）是预处理最常用的形式。它对数据中每个独立特征减去平均值，从几何上可以理解为在每个维度上都将数据云的中心都迁移到原点。在numpy中，该操作可以通过代码X -= np.mean(X, axis=0)实现。而对于图像，更常用的是对所有像素都减去一个值，可以用X -= np.mean(X)实现，也可以在3个颜色通道上分别操作。权重初始化权重初始化太小会造成网络崩溃，权重太大网络饱和，导致梯度消失。Xavier初始化w = np.random.randn(fan_in, fan_out) / np.sqrt(fan_in)如果使用ReLU激活函数，会造成一半左右的神经元消失在权重初始化的时候w = np.random.randn(fan_in, fan_out) / np.sqrt(fan_in / 2)批量归一化(Bathch Normalization)起因：在高斯范围内激活，将数据变为单位高斯数据批量归一化可以理解为在网络的每一层之前都做预处理，只是这种操作以另一种方式与网络集成在了一起归一化公式\hat x^{(k)} = \frac{x^{(k)}-E[x^{(k)}]}{\sqrt{Var[x^{(k)}]}}$k$代表输入的每个维度，分别对每一个维度独立计算经验均值和方差。运用：通常在全连接层或者卷积层之后、非线性层(激活函数层)之前加入BN。作用： 批量归一化使我们可以使用更高的学习率，而对初始化则不必那么小心 。在完成归一化操作之后，还(需要)进行额外的缩放操作y^{(k)}=\gamma^{(k)}\hat x^{(k)} + \beta^{(k)}可以学习$\gamma$和$\beta$以调整网络的饱和程度，若将其学习为均值和方差则可以完成于原数据的恒等映射。总结改进了整个网络的梯度流有了更高的鲁棒性，允许使用更广范围的学习率和不同的初始化下进行学习可以看作一种正则化方法Babysitting the Learning Processstep1:数据预处理step2：网络构造step3：检验网络是否合理step3：进行训练神经网络优化Fancier OptimizationSGDSGD的问题只对一个方向的敏感度高，会在不敏感的方向反复增减。会找到局部极小值或者鞍点(梯度为零)，在高维参数空间中，局部最小值不常见，常见的是鞍点。随机性，因为SGD使用的是minibatch(=1)，会产生噪声，如果在梯度下降时加入噪声会花费很长的时间解决：SGD+Momentum在局部最优点或者鞍点时，梯度为0，但依旧会有一个速度，能够越过这个点继续进行梯度下降。加入动量之后，噪声会被抵消，下降曲线更平滑。Nesterov MomentumAdaGrad&amp;RMSPropAdaGrad对于凸函数来说效果比较好，在接近极值点时会减小步长。Adam结合momentum&amp;AdaGrad&amp;RMSProp，加入第一动量和第二动量。有可能first_moment以及second_moment趋于0，人为造成第一步步长很大。改进：beta1=0.9,beta2=0.999,lr=1e-3or5e-4 is a great initialization point for many models.关于Learning RateLearning rate decacy over time指数衰减\alpha = \alpha_0e^{-kt}1/t衰减\alpha = \alpha_0/(1+kt)ps：SGDlr衰减很常见，但是Adam优化lr衰减很少用Second-Order Optimization(TODO)牛顿法-拟牛顿法正则化Dropout在正向传播时随机将一层中的节点置零()然后继续传播。hyperparameter=0.5 is common一般在全连接层使用Dropout,在卷积层中，可能是将某一通道全部置零。避免了特征之间的联系/组合可以看作model集成在predict函数中不进行随机失活，但是对于两个隐层的输出都要乘以$p$，调整其数值范围。 最后输出的期望值为原输出*hyperparameter。12345678910111213141516171819202122p = 0.5 # 激活神经元的概率. p值更高 = 随机失活更弱def train_step(X): """ X中是输入数据 """ # 3层neural network的前向传播 H1 = np.maximum(0, np.dot(W1, X) + b1) U1 = np.random.rand(*H1.shape) &lt; p # 第一个随机失活遮罩 H1 *= U1 # drop! H2 = np.maximum(0, np.dot(W2, H1) + b2) U2 = np.random.rand(*H2.shape) &lt; p # 第二个随机失活遮罩 H2 *= U2 # drop! out = np.dot(W3, H2) + b3 # 反向传播:计算梯度... (略) # 进行参数更新... (略) def predict(X): # 前向传播时模型集成 H1 = np.maximum(0, np.dot(W1, X) + b1) * p # 注意：激活数据要乘以p H2 = np.maximum(0, np.dot(W2, H1) + b2) * p # 注意：激活数据要乘以p out = np.dot(W3, H2) + b3Inverted dropout123456789101112131415161718192021""" 反向随机失活: 推荐实现方式.在训练的时候drop和调整数值范围，测试时不做任何事."""p = 0.5 # 激活神经元的概率. p值更高 = 随机失活更弱def train_step(X): # 3层neural network的前向传播 H1 = np.maximum(0, np.dot(W1, X) + b1) U1 = (np.random.rand(*H1.shape) &lt; p) / p # 第一个随机失活遮罩. 注意/p! H1 *= U1 # drop! H2 = np.maximum(0, np.dot(W2, H1) + b2) U2 = (np.random.rand(*H2.shape) &lt; p) / p # 第二个随机失活遮罩. 注意/p! H2 *= U2 # drop! out = np.dot(W3, H2) + b3 # 反向传播:计算梯度... (略) # 进行参数更新... (略)def predict(X): # 前向传播时模型集成 H1 = np.maximum(0, np.dot(W1, X) + b1) # 不用数值范围调整了 H2 = np.maximum(0, np.dot(W2, H1) + b2) out = np.dot(W3, H2) + b3运用dropout可能会用更长的时间进行训练，但是在收敛之后，模型的鲁棒性会更好。Batch NormalizationData Augmentationtransform imagecrops and scalesColor Jitter(色彩抖动)DropConnect随即将权重的一些值置零。Fractional Max Poolong(TODO)在最大池化层进行部分随机池化。Stochastic Depth(随即深度)在训练中，随机丢弃一些层，只用部分层。迁移学习不需要超大的样本集预训练模型PyTorch]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>计算机视觉</tag>
        <tag>卷积神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS231n-note-2]]></title>
    <url>%2F2019%2F10%2F15%2FCS231n-note-2%2F</url>
    <content type="text"><![CDATA[反向传播计算图根据链式法则进行反向传播，算出每个结点的梯度。max门：一个是1 一个是0乘法门：梯度互换梯度会在分支节点处累加sigmod函数\sigma(x) = \frac{1}{1+e^{-x}}梯度为\frac{d\sigma(x)}{dx}=(1-\sigma(x))\sigma(x)雅可比矩阵在向量分析中，雅可比矩阵是函数的一阶偏导数以一定方式排列成的矩阵，其行列式称为雅可比行列式。由球坐标系 到直角坐标系的转化由F函数给出 ：此坐标变换的雅可比矩阵是在实际的运用中，不用计算$4096*4096$的雅可比矩阵（如果输入向量为4096维）。一般的雅可比矩阵为对角矩阵，只用算出每一个维度的梯度。矩阵函数的梯度矩阵是其Jacobian矩阵的转置【Transposition】构造神经网络一个神经元前向传播的实例代码如下1234567class Neuron(object): # ... def forward(inputs): """ 假设输入和权重是1-D的numpy数组，偏差是一个数字 """ cell_body_sum = np.sum(inputs * self.weights) + self.bias firing_rate = 1.0 / (1.0 + math.exp(-cell_body_sum)) # sigmoid激活函数 return firing_rate常用激活函数每个激活函数（或非线性函数）的输入都是一个数字，然后对其进行某种固定的数学操作。Sigmod左边是Sigmoid非线性函数，将实数压缩到[0,1]之间。右边是tanh函数，将实数压缩到[-1,1]。\sigma(x) = \frac{1}{1+e^{-x}}它输入实数值并将其“挤压”到0到1范围内。更具体地说，很大的负数变成0，很大的正数变成1。在历史上，sigmoid函数非常常用，这是因为它对于神经元的激活频率有良好的解释：从完全不激活（0）到在求和后的最大频率处的完全饱和（saturated）的激活（1）。然而现在sigmoid函数已经不太受欢迎，实际很少使用了，这是因为它有两个主要缺点：Sigmoid函数饱和使梯度消失。sigmoid神经元有一个不好的特性，就是当神经元的激活在接近0或1处时会饱和：在这些区域，梯度几乎为0。回忆一下，在反向传播的时候，这个（局部）梯度将会与整个损失函数关于该门单元输出的梯度相乘。因此，如果局部梯度非常小，那么相乘的结果也会接近零，这会有效地“杀死”梯度，几乎就有没有信号通过神经元传到权重再到数据了。还有，为了防止饱和，必须对于权重矩阵初始化特别留意。比如，如果初始化权重过大，那么大多数神经元将会饱和，导致网络就几乎不学习了。Sigmoid函数的输出不是零中心的。这个性质并不是我们想要的，因为在神经网络后面层中的神经元得到的数据将不是零中心的。这一情况将影响梯度下降的运作，因为如果输入神经元的数据总是正数（比如在$f=w^T+b$中每个元素都$x&gt;0$），那么关于$w$的梯度在反向传播的过程中，将会要么全部是正数，要么全部是负数（具体依整个表达式$f$而定)。这将会导致梯度下降权重更新时出现z字型的下降。然而，可以看到整个批量的数据的梯度被加起来后，对于权重的最终更新将会有不同的正负，这样就从一定程度上减轻了这个问题。因此，该问题相对于上面的神经元饱和问题来说只是个小麻烦，没有那么严重。Tanhtanh(x)=2\sigma(2x)-1tanh非线性函数图像如上图右边所示。它将实数值压缩到[-1,1]之间。和sigmoid神经元一样，它也存在饱和问题，但是和sigmoid神经元不同的是，它的输出是零中心的。因此，在实际操作中，tanh非线性函数比sigmoid非线性函数更受欢迎。tanh神经元是一个简单放大的sigmoid神经元ReLU左边是ReLU（校正线性单元：Rectified Linear Unit）激活函数，当 $x=0$ 时函数值为0。当$x&gt;0$时函数的斜率为1。f(x) = max(0,x)优点：相较于sigmoid和tanh函数，ReLU对于随机梯度下降的收敛有巨大的加速作用（ Krizhevsky 等的论文指出有6倍之多）。据称这是由它的线性，非饱和的公式导致的。(右图)优点：sigmoid和tanh神经元含有指数运算等耗费计算资源的操作，而ReLU可以简单地通过对一个矩阵进行阈值计算得到。缺点：在训练的时候，ReLU单元比较脆弱并且可能“死掉”。举例来说，当一个很大的梯度流过ReLU的神经元的时候，可能会导致梯度更新到一种特别的状态，在这种状态下神经元将无法被其他任何数据点再次激活。如果这种情况发生，那么从此所以流过这个神经元的梯度将都变成0。也就是说，这个ReLU单元在训练中将不可逆转的死亡，因为这导致了数据多样化的丢失。例如，如果学习率设置得太高，可能会发现网络中40%的神经元都会死掉（在整个训练集中这些神经元都不会被激活）。通过合理设置学习率，这种情况的发生概率会降低。Leaky ReLUf(x) = max(0.01x,x)Leaky ReLU是为解决“ReLU死亡”问题的尝试。ReLU中当x&lt;0时，函数值为0。而Leaky ReLU则是给出一个很小的负数梯度值，比如0.01。Parametric Rectifier(PReLU)f(x)=max(\alpha x,x)$\alpha$可以作为反向传播训练的参数。ELU\left\{ \begin{aligned} x & & x\geq0\\ \alpha(e^x -1) & & x]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS231n note-1]]></title>
    <url>%2F2019%2F07%2F25%2FCS231n-note-1%2F</url>
    <content type="text"><![CDATA[图像分类目标：所谓图像分类问题，就是已有固定的分类标签集合，然后对于输入的图像，从分类标签集合中找出一个分类标签，最后把分类标签分配给该输入图像。虽然看起来挺简单的，但这可是计算机视觉领域的核心问题之一，并且有着各种各样的实际应用。在后面的课程中，我们可以看到计算机视觉领域中很多看似不同的问题（比如物体检测和分割），都可以被归结为图像分类问题。图像分类流程。在课程视频中已经学习过，图像分类就是输入一个元素为像素值的数组，然后给它分配一个分类标签。完整流程如下：输入：输入是包含N个图像的集合，每个图像的标签是K种分类标签中的一种。这个集合称为训练集。学习：这一步的任务是使用训练集来学习每个类到底长什么样。一般该步骤叫做训练分类器或者学习一个模型。评价：让分类器来预测它未曾见过的图像的分类标签，并以此来评价分类器的质量。我们会把分类器预测的标签和图像真正的分类标签对比。毫无疑问，分类器预测的分类标签和图像真正的分类标签如果一致，那就是好事，这样的情况越多越好。K-nearest算法（KNN）需要样本尽量高密度占据样本空间曼哈顿距离（L1）适合样本空间向量属性已知的情况，虽坐标轴变化值不同欧式距离（L2）适合样本向量为一般的通用向量超参数选择选取超参数的正确方法是：将原始训练集分为训练集和验证集，我们在验证集上尝试不同的超参数，最后保留表现最好那个。如果训练数据量不够，使用交叉验证方法，它能帮助我们在选取最优超参数的时候减少噪声。交叉验证有时候，训练集数量较小（因此验证集的数量更小），可以将训练集平均分成5份，其中4份用来训练，1份用来验证。然后我们循环着取其中4份来训练，其中1份来验证，最后取所有5次验证结果的平均值作为算法验证结果。线性分类图像数据预处理对输入的特征作归一化(normalization),对每个特征减去平均值去中心化，然后将数值分布区间变为[-1,1]，称为零均值中心化。损失函数多类支持向量机损失 Multiclass Support Vector Machine Loss针对第j个类别的得分就是第j个元素：。针对第i个数据的多类SVM的损失函数定义如下：在线性分类模型中，我们面对的是线性评分函数（），可以将损失函数的公式稍微改写一下：其中$w_j$是权重$W$的第j行，被变形为列向量。然而，一旦开始考虑更复杂的评分函数$f$公式，这样做就不是必须的了。$max(0,-)$称为折叶损失函数，但也会有平方折叶损失SVM，如何选择这两种可以通过交叉验证来进行选择。损失函数的正则化(Regularization)为了防止过拟合，需要对损失函数进行正则化操作。不是为了拟合数据而是为了减轻模型的复杂度。正则项$\lambda R(W)$超参数$\lambda$用来平衡Data loss项和Regularization常见的正则化批量归一化，随机深度L1 更倾向于稀疏解L2 更倾向于鲁棒性更强的解（鲁棒性：鲁棒性是指异常样本对于算法的整体性能影响不大）多项式逻辑斯蒂克损失(softmax loss)在Softmax分类器中，函数映射保持不变，但将这些评分值视为每个分类的未归一化的对数概率，并且将折叶损失（hinge loss）替换为交叉熵损失（cross-entropy loss）。公式如下： 或者 在上式中，使用$f_j$来表示分类评分向量$f$中的第j个元素。和之前一样，整个数据集的损失值是数据集中所有样本数据的损失值$L_i$的均值与正则化损失$R(W)$之和。其中函数$f_j(z)=\frac{e^zj}{\sum_ke^zk}$被称作softmax 函数：其输入值是一个向量，向量中元素为任意实数的评分值（$z$中的)，函数对其进行压缩，输出一个向量，其中每个元素值在0到1之间，且所有元素之和为1。优化梯度​ 在权重空间中找到一个方向，沿着该方向能降低损失函数的损失值。其实不需要随机寻找方向，因为可以直接计算出最好的方向，这就是从数学上计算出最陡峭的方向。这个方向就是损失函数的梯度（gradient）梯度下降12345# 普通的梯度下降while True: weights_grad = evaluate_gradient(loss_fun, data, weights) weights += - step_size * weights_grad # 进行梯度更新1234567# 普通的小批量数据梯度下降#可以减少运算成本while True: data_batch = sample_training_data(data, 256) # 256个数据 weights_grad = evaluate_gradient(loss_fun, data_batch, weights) weights += - step_size * weights_grad # 参数更新]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件安全设计]]></title>
    <url>%2F2019%2F06%2F14%2F%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[软件安全设计CH01软件与软件安全计算环境与软件二进制基础位运算所谓位运算是指进行二进制位的运算。在系统软件中，常要处理二进位的问题。**不同长度的数据进行位运算**如果两个数据长度不同(例如long型和int型)进行位运算时(如a &amp; b,而a为long型,b为int型),系统会将二者按右端对齐。如果b为正数,则左侧16位补满0。若b为负数,左端应补满1。如果b为无符号整数型,则左侧添满0。指令系统与指令集指令系统：计算机的指令系统就是指该计算机能够执行的全部指令的集合。指令系统也称指令集软件的形式与概念软件与一个系统（尤指计算机系统）有关的程序、步骤和有关文件编制的完整集合。特指特定类型计算机所使用的程序的总称，连同与计算机或程序有关的资料，例如手册、图表和操作指令。程序根据一定的需要事先编写的一系列控制计算机工作的命令，就称为计算机程序。计算机系统的组成完整的计算机系统包括计算机硬件系统和计算机软件系统。软件的主要内容程序、步骤及数据、信息手册等相关资料功能：针对一个系统（计算机），合理组织工作。两个层次：–直接与硬件相关–合理组织工作，完成特定任务。软件的形式软件分为系统软件和应用软件，应用软件以系统软件为基础。信息安全与软件安全信息与信息安全信息安全属性安全性，可用性，保密性，可控性，可靠性软件安全软件安全：软件在恶意攻击下能够正确地完成其功能。软件安全性：软件安全性是指软件不被恶意使用或者攻击进而造成用户信息资产损失的属性。软件安全属性：可信性：保护敏感信息不被未授权用户访问完整性：保护数据不被更改或破坏可用性：确保资源被授权用户的使用软件安全保护：(1) 软件自身安全：防止软件丢失、被破坏、被篡改、被伪造(2) 软件存储安全：可靠存储，保密存储，压缩存储，备份存储(3) 软件通信安全：安全传输、加密传输、网络安全下载、完整下载(4) 软件信用安全：合法用户与非法用户，授权访问，防止软件滥用，防止软件窃取，软件的非法复制(5) 软件运行安全 ：确保软件正常运行，功能正常软件安全研究：如何设计、构造、验证和维护软件以保证其是安全的。包括改进和实现软件安全的架构或结构、工具、方法ISO7498-2主要内容在ISO7498-2中描述开放系统互连安全的体系架构，提出设计安全的信息系统的基础架构应该包含的：5种安全服务，对5种安全服务提供支持的8类安全机制，需要进行的5种OSI安全管理方式5种安全服务鉴别服务、访问控制、数据完整性、数据保密性、抗抵赖8种安全机制加密、数字签名、访问控制、数据完整性、数据交换、业务流填充、路由控制、公证5种普遍性安全管理机制可信功能度、安全标记、事件检测、安全审计跟踪、安全恢复软件安全的概念漏洞计算机系统具有的某种可能被入侵者恶意利用的属性。有时安全漏洞也称为脆弱性（Vulnerability）。本质：漏洞是系统的一组特性，恶意的主体（攻击者或者攻击程序）能够利用这组特性，通过已授权的手段和方式获取对资源的未经授权访问，或者对系统造成损害。脆弱状态从已授权的状态变换到未授权状态。攻击攻击是以授权状态或脆弱状态开始，以受损状态为目标的状态变换安全事件当系统的某个漏洞被入侵者渗透（exploit）而造成泄密ISO9126标准ISO9126标准：软件产品评价－质量特性及其使用指南6个质量特性功能性准确性：软件提供给用户功能的精确度是否符合目标。（例如：运算结果的准确，数字发生偏差，多个0或少个0）互操作性：软件与其它系统进行交互的能力。（例如：PC机中WORD和打印机完成打印互通）保密安全性：软件保护信息和数据的安全能力。（主要是权限和密码）功能性的依从性：遵循相关标准（国际标准、国内标准、行业标准、企业内部规范）可靠性成熟性：软件产品为避免软件内部的错误扩散而导至系统失效的能力（主要是对内错误的隔离）容错性：软件防止外部接口错误扩散而导致系统失效的能力（主要是对外错误的隔离）易恢复性：系统失效后，重新恢复原有的功能和性能的能力。可靠性的依从性：遵循相关标准易用性易理解性：软件交互给用户的信息时，要清晰，准确，且要易懂，使用户能够快速理解软件。易学性：软件使用户能学习其应用的能力。易操作性：软件产品使用户能易于操作和控制它的能力。易用性的依从性：遵循一定的标准。效率时间特性：软件处理特定的业务请求所需要的响应时间。资源利用性：软件处理特定的业务请求所消耗的系统资源。效率依从性：遵循一定的标准。维护性易分析性：软件提供辅助手段帮助开发人员定位缺陷产生的原因，判断出修改的地方。易改变性：软件产品使得指定的修改容易实现的能力。（降低修复问题的成本）稳定性：软件产品避免由于软件修改而造成意外结果的能力。易测试性：软件提供辅助性手段帮助测试人员实现其测试意图。维护性的依从性：遵循相关标准。可移植性适应性：软件产品无需作相应变动就能适应不同环境的能力。易安装性：尽可能少的提供选择，方便用户直接安装。共存性：软件产品在公共环境中与其它软件分享公共资源共存的软件。易替换性：软件产品在同样的环境下，替代另一个相同用途的软件产品的能力。可移植性的依从性：遵循相关的标准。9126质量模型缺陷安全性是软件功能性的子属性充分体现了对安全的忽视。安全的代码（secure code）： 能够抵抗恶意攻击的代码；安全的代码同时也是健壮的代码（robust code）安全性代码（security code）： 实现安全功能的代码。安全的程序：安全隐含某种程度的信任（trust），程序实现了期望的机密性、完整性、可用性及其功能。CH02典型软件安全问题安全问题的来源根本来源：漏洞(漏洞是软件的属性，是软件安全威胁的根源)、攻击者、软件存在的攻击路径－攻击面问题。漏洞产生漏洞的原因软件或协议设计时的瑕疵软件或协议实现中的弱点软件本身的瑕疵系统和网络的错误配置漏洞的两种类型设计漏洞：设计错误，往往发现于软件的安全功能特性中。实现漏洞：来源于软件实际编码中的安全缺陷。意外行为和缺陷意外行为（Unexpected Behavior）：也称程序安全缺陷，是由于程序脆弱性引起的不适当的程序行为。缺陷（Flaw）：缺陷可以是故障（Fault），或者失效（Failure）程序安全缺陷可能来源于任何种类的软件错误：无意或疏忽的故意或有意的缺陷的类型：有意的缺陷恶意的非恶意的无意的缺陷确认错误域的错误顺序化和混淆现象不完全的身份识别和认证边界条件违反其它可利用的逻辑错误APPLE DEVELOPER常见软件缺陷buffer overflows 缓冲区溢出invalidated input 未校验输入race conditions 资源竞争access-control problems 访问控制问题weaknesses in authentication, authorization, or cryptographic practices 认证、授权、加密缺陷常见的安全设计问题密码技术使用的败笔创建自己的密码技术选用了不当的密码技术依赖隐蔽式安全编写到程序中的密钥错误地处理私密信息对用户及其许可权限进行跟踪的薄弱或缺失会话管理薄弱或者缺失身份鉴别薄弱或缺失授权薄弱或缺失有缺陷的输入验证没有在安全的上下文环境中执行验证，如在服务器验证而在客户端没有验证验证例程不集中，验证应尽可能靠近用户输入，并应集中以便于核实不安全的组件边界薄弱的结构性安全过大的攻击面在过高权限级别上运行进程没有纵深防御失效时的处理不安全其他设计缺陷代码和数据混在一起错将信任寄予外部系统不安全的默认值未做审计日志编程语言问题C/C++的问题没有安全的本地字符串类型，也没有安全而易用的字符串处理函数。PS：1234567//C中以NULL终止符表示一个字符串的末尾。//如：Char buffer[]=“small string”//没有确切地存储字符串的长度，该字符串的长度要//程序员管理。//当程序员处理这个长度犯错时，就会导致超过缓冲//区结尾部分的内存被覆盖。缓冲区溢出（BufferOverflow）——一个最典型的例子：123char sample[10];for (i=0; i&lt;10; i++) sample[i] = 'A'; sample[10] ='B'; //缓冲区超限覆盖栈中的函数返回地址用于从被调用的函数返回到某个位置的返回地址驻留在栈中，紧接在本地变量之后；返回地址是驻留在栈中的一段隐蔽的数据，栈中其余部分是传递给该函数的变量；编译后的程序在调用这个函数之前会将这个地址数据放在栈中，以使程序获知当这个函数执行完后转到哪里；通过把栈中某个变量产生缓冲区溢出，就可以覆盖栈中的这个返回地址。PS:典型例子－栈溢出（Stack Smashing）1234567891011121314Void createFullName (char* firstName, Char* lastName)&#123;Char fullName[1024];Strcpy(fullName, firstName);Strcat(fullName, “ “)Strcat(fullName, lastName);&#125;/*接受参数名字和姓氏，放到一起，中间用空格分隔；变量fullName的声明方式，使其在堆栈中驻留；如果firstName和lastName太长，可能会使fullName超出1024；调用strcpy 和strcat函数破坏内存栈，会导致程序崩溃；如果控制参数使得fullName发生缓冲区溢出，就可以造成程序的恶意攻击。*/预防栈溢出的方法：精确控制输入变量的长度（如上述firstName和lastName的长度限制为511个字节）；建议使用strncpy和strncat替代strcpy和strcat；避免使用无界字符串；创建一个新的或使用已有的字符串缓冲区模块。printf类型的格式化函数－格式化字符串攻击例子：sprintf(target, “Name:%s, count:%d”, person, num);该例子获取字符串Name和整型数count，放入target（目标缓冲区）如果：sprintf（target，“Name: %s%s%s%s, count:%d”,num）；此时该函数将从栈中读取四个字符串，但事实上栈中不存在这四个字符串，程序读取栈中原本用于其他目的的值。整数溢出在C语言中，整数的正负标识是默认的；当一个整数值增长从而超过了其最大可能的值并循环到成为一个负数的时候，将发生整数溢出；C语言没有任何措施预防整数溢出。如果攻击者通过用户输入操纵整数长度，就可以让这个值溢出，引起程序的处理发生错误。例：整数2147483647加1，发生溢出，成为​ -2147483648PS：123456789Int copy_something(char *buf, int len) &#123; char kbuf[800]; if(len&gt;sizeof(kbuf) &#123; return -1; /*1*/ &#125; return memcpy(kbuf, buf, len); /*2*/&#125;在 1 利用符号整数进行了一次边界检查；如果能够控制程序，传递一个负值给len，则可能通过1的检查；在2中，memcpy接受无符号数作为长度，len被解释为一个大的无符号数，导致超越缓冲区kbuf的末尾；具有讽刺意味的是：1所进行的边界检查是为了预防缓冲区溢出。平台的实现问题平台：平台是指程序在其中所运行的环境，包括操作系统以及与之交互的组件。平台问题1：符号链接符号链接（Symbolic link, 简写为symlink）：文件系统中指向其他文件的文件。符号链接等效于其指向的文件。程序打开的是一个符号链接，实际打开的是该符号链接指向的文件。符号链接问题攻击者可以使用程序预计要操作的文件名创建一个符号链接，使该文件名指向希望的文件；利用符号链接，攻击者事实上可以启动系统中的任何程序。解决程序员或使用者创建、打开、删除文件，或更改文件权限，必须检查该文件的符号链接，不可以基于文件名做任何安全方面的判定。权限攻击的例子：如果程序以攻击者没有的权限运行，比如作为SUID（系统用户身份），攻击者可以借此发动一次权限提升。平台问题2：目录遍历典型例子：CIFS是WINDOWS的文件共享协议，允许计算机通过网络访问彼此的文件系统。利用目录遍历，攻击者可通过使用“..”符号上升到文件系统的上一级目录，从而对文件共享程序进行欺骗，进而获得对不在共享目录下的目录进行访问。平台问题3：字符转换平台支持不同类型的字符编码，存在多种不同的表示某个字符的方式。程序接受用户的输入，为了满足安全需求，通常会要求进行安全检查，以确保输入的字符串对该程序设计是有效的。当平台进行升级的时候可能会引入新的字符编码。常见的应用程序安全问题引起原因：应用程序的某个组件的恶意数据引起，这些恶意数据在其另一个组件中被当作了合法代码；对涉密信息的不当处理应用安全问题1：SQL注入攻击者通过操纵程序的某种输入，在连接到SQL数据库的应用程序上执行自己所构造的查询。​ 预防SQL攻击方法：过滤所有输入，确保输入字段只包含所需要的字符；尽量避免使用动态生成的SQL。SQL注入典型例子：​ 但如果我们刻意的去绕过登录认证呢？猜想下面这个sql语句，单说用户名，开发人员很可能会这样去数据库里对比：Select from sys_user where username=‘XXX’当然可能更复杂，假如我们在输入框里输入下面一句特殊的字符会如何？’or‘1=1这是段神奇的字符，因为这样这个sql就变成：Select from sys_user where username=‘’or‘1=1’ ‘这样我们就跳过了用户名的验证，实现了入侵。这样的结果，导致无条件越过用户名验证。应用安全问题2：跨站点执行脚本利用Internet上某些环境（或WEB站点）的受信任级别高于其他环境。来自非受信环境的攻击者可在受信的环境注入数据，使其在受信环境作为脚本予以执行。跨站点执行脚本还可以用来访问数据，如用户cookies。跨站点执行脚本的例子：123456789101112假如有下面一个textbox： &lt;input type="text" name="address1" value="value1from"&gt;value后面的值是来自用户的输入，如果用户输入 "/&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&lt;!-那么就会变成 &lt;input type="text" name="address1" value=""/&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&lt;!- "&gt; 嵌入的JavaScript代码将会被执行 或者用户输入的是："onfocus="alert(document.cookie)那么就会变成&lt;input type="text" name="address1" value=""onfocus="alert(document.cookie)"&gt;事件被触发的时候嵌入的JavaScript代码将会被执行开发过程问题安全需求和前提条件的文档记录缺乏交流和文档匮乏缺少安全过程部署上的薄弱性部署的执行者一般不属于开发团队软件错误地设置文件或注册表的键值，使系统上的其他用户可以进行更改使软件安装时具有不必要的权限。OWASPThe Open Web Application Security ProjectOWASP Top 10A1-注入：攻击者发送的恶意数据可以欺骗解释器，以执行计划外的命令或者在未被恰当授权时访问数据。A2-失效的身份认证A3-跨站脚本：XSS允许攻击者在受害者的浏览器上执行脚本，从而劫持用户会话、危害网站、或者将用户转向至恶意网站。A4-不安全的直接对象引用A5-安全配置错误A6-敏感信息泄露A7-功能及访问控制缺失A8-跨站请求伪造（CSRF）A9-使用含有已知漏洞的组件A10-未验证的重定向和转发CH03安全软件工程SSE-CMM开发SSE-CMM的目的降低开发和维护系统的花费；提高工程进度和预算的一致性；选择合适的承包者。发起者：国防部、国家安全局主要内容能力方面能力级别能力级别1：非正式执行公共特征执行基本实施能力级别2：计划与跟踪公共特征计划执行规范化执行验证执行跟踪执行能力级别3：充分定义公共特征定义标准过程执行已定义的过程协调安全实施能力级别4：定量控制公共特征建立可测的质量目标客观地管理过程的执行能力级别５：连续改进公共特征改进组织能力改进过程的有效性域方面工程和安全实施是安全工程过程中必须存在的性质，指出特殊过程区的目的并属于该过程区每个过程区（PA）是一组相关安全工程过程的性质，当这些性质全部实施后则能够达到过程区定义的目的。一组过程区指出活动的同一通用区关于安全工程与评估安全工程分三个基本过程：风险、工程和保证风险(风险信息)风险过程是要确定产品或者系统的危险性，并对这些危险性进行优先级排序工程(解决方案)工程过程是针对面临的危险性，安全工程过程与相关工程过程一起来确定并实施解决方案保证(保证论据)保证过程是建立起对解决方案的信任，并把这种信任传达给顾客SSAM(SSE-CMM评定方法)SSAM 为了进行评定，收集数据广泛、严格，每个数据有充分的证据。此方法在评定过程中最大程度地发挥了SSE-CMM模型的功效。此方法：决定实施安全工程过程的能力为了评定定义了安全工程环境在评定时巧妙地使用了SSE-CMM体系结构中的两个方面。SDL-安全开发生命周期模型Secure Development Lifecycle微软可信计算(TrustWorthy Computing )努力的一个组成部分基于并行理念的标准软件开发过程基于威胁建模和测试SDL概览SDL从三个方面考虑软件安全的保障。设计安全为了保护软件自身以及软件处理的信息,并抵御攻击,软件应该从架构,设计和实现上进行考虑缺省安全设计者应该假定安全缺陷将会出现。为了当攻击者对软件存在的缺陷进行攻击时使损害降到最小, 软件的缺省状态应该保证安全。比如 最小特权原则。提交安全工具和指南应该随着软件提供以帮助最终用户或管理员安全使用。关于软件的更新应该容易提交。SDL过程0：教育和意识安全教育的内容安全设计基础：受攻击面分析、深度防御、最小特权、安全默认配置威胁建模：设计威胁建模、编码威胁建模、测试威胁建模1：项目启动判断SDL是否覆盖应用、任命安全顾问、组建安全领导团队、确保在BUG追踪管理过程中包含安全、隐私类BUG、建立BUG标准2：定义并遵从设计最佳实践常见安全设计原则经济机制、默认失效保护、安全中介、公开设计、权限分离、最小特权、最少公共机制、心里可接受程度受攻击面分析与降低分析枚举所有接口、协议以及可执行代码的过程。软件的受攻击面代码、接口、服务、协议、其他降低核心观点：在所有代码中存在至少一个或多个漏洞的可能性一定不为零，一部分严重漏洞会导致用户不得不接受妥协。唯一解决上述问题的方法是将代码的利用率降至为零。受攻击面降低的方法：降低默认执行的代码量限制可访问到代码的人员范围限定可访问到代码的人员身份降低代码所需权限。3：产品风险评估安全风险评估、隐私影响分级、统一各种因素4：风险分析/威胁建模益处有助于整个风险管理过程在系统进入编码阶段前发现系统威胁开发团队通过威胁建模可以重新验证其架构与设计有助于进一步明确针对应用以及环境采取相应的解决对策有助于指导整个代码审核过程指导整个渗透测试过程威胁建模过程定义应用场景收集外部依赖列表定义安全假设创建外部安全备注绘制待建模应用的一个或多个数据流图确定威胁类型识别系统威胁判断风险规划消减措施5：创建安全文档、工具以及客户最佳实践6：安全编码策略7：安全测试策略安全测试内容：模糊测试、渗透测试、运行时测试、重审威胁模型、重估受攻击模型8：安全推进过程9：最终安全评审10：安全响应规划使用SDL不能保证生产绝对安全的软件：开发团队一定会出错新漏洞一定会变化规则一定会变化11：产品发布12：遵从计划、尽可能补救、理解取舍之道CH04软件安全测试软件安全测试安全性测试是指有关验证应用程序的安全等级和识别潜在安全性缺陷的过程。应用程序级安全测试的主要目的是查找软件自身程序设计中存在的安全隐患，并检查应用程序对非法侵入的防范能力。安全指标不同测试策略也不同。安全测试的法律问题安全测试必须得到授权安全测试工具的应用必须得到授权穿透测试实验必须得到授权在未得到明确授权的情况下，不允许针对第三方系统进行穿透测试的实验软件安全测试的方法静态测试主要通过对源代码进行安全扫描，根据程序中数据流、控制流、语义等信息与其特有软件安全规则库进行匹对，从中找出代码中潜在的安 全漏洞。静态的源代码安全测试是非常有用的方法，可以在编码阶段找出所有可能存在安全风险的代码，这样开发人员可以在早期解决潜在的安全问题。静态代码测试比较适用于早期的代码开发阶段，而不是测试阶段。动态的测试动态测试也称渗透测试，penetrate渗透测试是常用的安全测试方法。是使用自动化工具或者人工的方法模拟黑客的输入，对应用系统进行攻击性测试，从中找出运行时刻所存在的安全漏洞。渗透测试的特点就是真实有效，一般找出来的问题都是正确的，也是较为严重的。渗透测试的缺点是模拟的测试数据只能到达有限的测试点，覆盖率很低。程序数据扫描一个有高安全性需求的软件， 在运行过程中数据是不能遭到破坏的，否则就会导致缓冲区溢出类型的攻击。数据扫描的手段通常是进行内存测试，内存测试可以发现许多诸如缓冲区溢出之类的漏洞，而这类漏洞使用除此之外的测试手段都难以发现。例如，利用专门的工具对软件运行时的内存信息进行扫描，检查是否存在导致隐患的信息。安全测试点程序安全性测试数据安全性测试典型问题程序安全性测试典型问题参考① 明确区分系统中不同用户权限;② 系统中会不会出现用户冲突;③ 系统会不会因用户的权限的改变造成混乱;④ 用户登陆密码是否是可见、可复制;⑤ 是否可以通过绝对途径登陆系统(拷贝用户登陆后的链接直接进入系统);⑥ 用户推出系统后是否删除了所有鉴权标记，是否可以使用后退键而不通过输入口令进入系统。网络安全测试典型问题参考① 测试采取的防护措施是否正确装配好，有关系统的补丁是否打上;② 模拟非授权攻击，看防护系统是否坚固;③ 采用成熟的网络漏洞检查工具检查系统相关漏洞;④ 采用各种木马检查工具检查系统木马情况;⑤ 采用各种防外挂工具检查系统各组程序的客外挂漏洞。数据安全测试考虑问题参考：① 系统数据是否机密(比如对银行系统，这一点就特别重要，一般的网站就没有太高要求);② 系统数据的完整性;③ 系统数据可管理性;④ 系统数据的独立性;⑤ 系统数据可备份和恢复能力(数据备份是否完整，可否恢复，恢复是否可以完整)。安全漏洞分级DREAD模型DREAD模型：进行威胁程度级别分析的有效技术。潜在的破坏（Damage potential）如果该漏洞被利用，所产生的破坏程度再现性（Reproducibility）探测并利用该漏洞所需要的努力要多久可利用性（Exploitability）是否需要身份鉴别？受影响用户（Affected users）漏洞利用的影响面有多大可发现性（Discoverability）漏洞研究人员或黑客找出该漏洞的可能性TRAP模型基于可利用性提出。因素：时间（Time）可靠性（Reliability）/再现性（Reproducibility）访问（Access）定位（Positioning）安全的常规测试方法基于风险的安全测试安全测试的目标在给定的时间和资源不变的情况下，尽可能多地找出最为严重的安全缺陷。威胁建模=风险建模基于风险的测试是软件测试的常规方法基于风险的测试的三个步骤信息搜集信息搜集的目的：熟悉程序的设计、了解程序访问入口点位置、了解程序所涉及的信息资产－需要保护的信息信息搜集的方法：程序设计文档的评审、与设计人员和架构师会谈、运行时分析－使用调试和诊断程序威胁（风险）建模威胁建模的目的：排定测试优先级，找出测试区域，发现系统弱点威胁建模步骤：识别威胁路径：目的：识别应用程序级别最高的风险领域，确定相应的保护措施步骤：①了解应用程序平台和编程语言的整体强度②确定用户的访问类别③建立并分析数据流图识别威胁：目的：深入识别沿威胁路径的处理，逐一理清与处理相关的每一种威胁。针对威胁路径的每一个处理组件的问题列表：–该组件执行什么样的处理–该组件如何确定身份–该组件信任数据或者其他组件吗–该组件修改了什么数据–该组件有何外部连接在一个威胁路径上的9个高风险活动：①数据解析 ②文件访问 ③数据库访问 ④生成子进程 ⑤身份鉴别 ⑥授权 ⑦同步或会话管理 ⑧处理私密数据 ⑨网络访问识别漏洞目的：找出可能存在于组件中的实际漏洞。缓解措施：–数据验证测试–资源监视–关键功能的访问控制搜寻漏洞的方法及途径：–安全设计审查–安全代码审查–安全测试风险分级/排定优先级可用性分析判定可利用性的目的：判断漏洞是否可被攻击者利用。原则：在开发中直接修补一个可能会被利用的问题比花时间判定其是否会被利用容易白盒、黑盒和灰盒测试白盒测试也称明盒测试、开盒测试或信息充分测试。白盒测试可以看作是内部的攻击。测试人员可以访问源代码和设计文档，可以进行威胁建模或逐行的代码检查。白盒测试是找出漏洞最为有效的方法。黑盒测试以局外人的身份对系统进行攻击，使用工具检查系统的攻击面，并探查系统的内部信息。黑盒测试是白盒测试的补充。方向工程团队利用黑盒测试验证隐蔽式安全方法的强度。灰盒测试组合使用白盒测和黑盒测试。–白盒测试用于发现在设计和开发中详细说明的功能中的缺陷；–黑盒测试在无法了解程序内部信息的时候找出缺陷。程序开发中的调试运行是典型的灰盒测试方法。典型安全测试工具JAVA代码安全分析工具：–IBM AppScan Source Edition–Fotify Static Code Analyzer–FindbugsC++代码安全分析工具：–C++Test–IBM AppScan Source Edition–Fotify Static Code AnalyzerVisual Studio（27.78%）JavaScript代码安全工具：–Google’s Closure Compiler–JSHintPython代码安全工具：–Pychecker–PyCharm–Pylint–PySEC，开源WEB应用安全测试工具：IBM AppScanSoapUIHP的WebInspectWEB应用的开源工具：FirebugOWASP ZAPAndroid App安全测试工具：Android TamerAndroBugsMobisecSQL注入测试工具：SQLInjetorSQL Power InjectorOWASP SQLiX网络状态监控与分析工具：WiresharkCH05编写安全的代码SD3安全设计安排具体的安全设计的人员；进行安全教育；确保威胁分析已经完成；符合安全设计和编码的指导原则；尽可能修补任何安全编程指南上的BUG;确保安全指南是逐步改进的；针对已经修复的缺陷开发回归测试；简化代码和安全模型；在打包以前完成穿透测试。缺省安全缺省状态下，不要设置所有的特点和功能；允许最小权限；恰当的资源保护。安全提交确认程序给管理员提供了安全功能；尽可能提供高质量的补丁；提供足够的信息以使用户安全的使用软件。安全规则学习错误；最小化攻击面；使用深度防御；使用最小权限；应用缺省安全；记住兼容性的倒退是痛苦的；假定外部系统是不安全的；基于错误计划；切记安全的特性不等于安全特性；Never depend on security through obscurity( 朦胧，晦涩，不分明) alone不要混合编码和数据；正确修复安全问题。学习错误学习错误从填写一个文档开始，文档内容：产品名称；产品版本；联系人；BUG数据库编号；脆弱性描述；脆弱性的隐含意义；在产品的缺省安装中，这个问题是否存在？设计，开发和测试人员能够做什么来防止这个缺陷？修复的细节，包括代码的区别，如果可以填写。最小化攻击面需要计算下面的内容：（1）打开socket、命名管道、RPC端点的数量；（2）服务的数量；缺省运行服务的数量；服务以提高权限运行的数量；（3）ISAPI过滤器和应用的数量；动态WEB页面数量；加入管理员组帐号的数量；（4）文件，目录和注册键值的数量，带有弱访问控制列表。CH06信息系统的安全建模莫分析信息系统及其特征MISMIS是借助于自动化数据处理手段进行管理的系统，由计算机硬件、软件（包括：系统软件、应用软件和管理学软件包）、数据库各种规程和人共同组成。是由人、计算机等组成的能进行管理信息的收集、传递、加工的信息系统。主要特征依赖于计算机的；涉及了计算机的软件和硬件；实现数据的采集、传递、加工、处理功能。系统主要特性1 整体性—系统的各个部分一定以整体目标为目标，追求全局最优；2 目的性—一个系统一定是具有明确目标的，并完成一定的功能；3 层次性—一个系统可以分为若干层次和子系统；4 边界性—每一个系统都能够明显地区别于其他系统，系统之间有明确的界限；5 关联性—系统包括若干元素，元素之间存在一定的关联性；6 环境性—系统处于一定的环境之中并受环境影响。信息系统的类型宏观的国家经济信息系统；面向基层的企事业管理信息系统；事务型管理信息系统；办公型管理信息系统；专业型管理信息系统等；既有典型的MRP，ERP，SCM等通用的信息系统，也有针对特定业务的系统。许许多多以计算机为核心的，实现数据的采集、存储、操作的系统都属于信息系统的范畴。运行环境要素物理世界；管理者实体—拥有授权管理、变更、修复和使用系统的人或者其他系统，其中一些被授权人可能缺乏有效管理系统的能力或具有恶意的目的；使用者—在使用界面接受来自系统的服务的实体；提供者—在系统的使用界面提供服务的实体；基础组织—对系统提供信息源、通信链接、能源、冷气等特定服务的实体；入侵者—企图超越所拥有的权限并且变更服务或阻止服务，变更系统的功能或性能或者存取秘密信息的实体。信息系统的安全问题ISO7498-2标准中所定义的五种安全服务类型：身份鉴别（Authentication）访问控制（Access Control）数据保密（Data Confidentiality）数据完整性（ Data integrity）抗抵赖（Non-reputation）安全模型系统使用者：用户 系统管理员 信息主管(企业主管)系统划分：用户界面逻辑 业务逻辑 异常检测机系统安全实现的主要功能：访问控制 抗抵赖 数据保密 身份鉴别授权机制 日志审计 系统异常探测用户界面逻辑用户界面逻辑部分：数据访问、登录控制。在系统启动时，用户首先登录系统，通过系统验证后才可以完成数据访问功能。登录控制主要功能：口令验证，口令修改，口令数据的加密，登录时间记录设计考虑：用户ID：从权限数据中提取出相应的用户名。采用用户编号的原因是回避重名，简化输入，同时用户号本身也可以增加一定的安全性。用户修改口令，而不是系统管理员：系统管理员对用户授权，但是口令由用户在用户界面输入，并加密存储至后台数据库中，以避免系统管理员获取用户口令造成泄密初始口令的安全：系统的第一次运行关键是初始口令的赋予，由信息主管（或其他高层）完成用户身份的确认，同时要求用户第一次登录时必须更改初始口令。口令安全：口令长度限制；口令字符集限制；口令有效期限制。用户封锁：所谓的用户封锁是当出现用户多次登录系统失败的情况时，系统将锁定用户的操作并提示，解锁过程必须由系统管理员完成。业务逻辑在系统的业务逻辑部分主要包括数据服务、权限管理、日志审计三个部分。数据服务主要安全任务是完成特定数据的加密、解密，日志数据的存储，权限及用户信息的存储。权限管理完成用户的授权，包括两个部分：系统管理员和信息主管。信息主管负责系统启动和初始授权，系统管理员负责日常权限管理、日志审计、系统状态监控、异常监测、用户锁定处理。日志审计对用户的操作行为进行跟踪，提供根据时间、用户、系统的检索手段。是保证安全，提高安全可信性的重要手段。异常探测机异常探测机实现的主要功能：–是日志的分析；–网络状态的安全监测；–提供一定的日志文件保护机制。异常检测独立于业务逻辑的目的1独立的程序，便于进一步发展，有较大的发展空间；2位于业务和用户进程之外，能够对其进行监控；3不对信息系统运行发生干扰；4使该探测器成为系统的可选件。异常行为探测区别内容异常探测机IDS检测范围网络内部行为网络外部行为实现方式软件硬件与系统关系可以存取系统数据不能存取系统数据保护目标信息系统网路异常行为用户身份的攻击：非法用户针对用户ID进行攻击，试图猜测用户身份。口令攻击：在已知用户身份的情况下，猜测口令，进行口令攻击。服务器的异常访问：这里是指服务器计算机和WEBSERER等专用服务程序。类似DOS攻击的方式在局域网内也是有可能发生的。数据库异常连接：对数据库的访问主要是通过特定端口进行的，可能的威胁来自合法的客户端程序或者非法的客户端程序。数据库文件变动异常：系统中数据库文件的变动包括文件访问、拷贝、删除等操作。日志文件攻击：针对日志文件发起的包括文件删除、修改等非法操作。日志分析针对日志文件自身的攻击主要有：日志数据的删除系统本身不向用户提供日志数据的删除功能。针对非法用户的攻击，如果是单独的日志文件，当系统启动后，该文件置于异常探测机的保护之下如果是数据库数据，则依赖于操作系统和数据库本身的保护机制。无论是系统操作员还是系统管理员的合法用户不具有日志文件删除的能力，而来自于客户端和服务器端的非法用户受到异常探测机、操作系统、数据库系统的安全机制约束。日志数据的修改系统不向用户提供日志修改功能。日志浏览也作为重要功能进行授权。由于单独的日志文件置于了异常探测机的保护之下，所以可以避免合法用户的修改。非法用户试图对记录于数据库中的日志数据进行修改时，则受到操作系统和数据库系统的约束。日志数据审计和异常模式手动审计自动审计和报警网络异常探测机网络异常探测机的主要功能是针对来自网络的信息进行分析，提供对信息系统的保护报警。探测器并不是通用的系统异常探测器。功能：数据流量检测、服务端口连接数量检测、文件访问限制、日志文件保护CH07WEB应用安全WEB应用定义采用HTTP协议完成通信的应用程序与后台WEB Server实现交互的程序与互联网（Internet）服务器，包括Web Server，database server进行交互的程序位于中间层，进行数据交互或者其他服务程序安全现状实现WEB应用安全非常困难WEB应用环境包括多个系统WEB应用大部分运行于INTERNET，具有更广的攻击面在WEB应用的运行中，具有更多的临时决策，以支持系统的运行，系统状态具有更多的可变性许多支持系统没有得到恰当的保护微软WEB应用安全框架WEB应用安全建模活动：Web 应用程序的威胁建模目的：确定方案中的相关威胁和漏洞，以帮助您构建应用程序的安全设计。输入：•主要用例和使用方案•数据流•数据架构•部署关系图输出：•威胁列表•漏洞列表五个步骤：步骤 1 ：确定安全目标。目标清晰有助于将注意力集中在威胁建模活动上，以及确定后续步骤要做多少工作。步骤 2 ：创建应用程序概述。逐条列出应用程序的重要特征和参与者有助于在步骤 4 中确定相关威胁。步骤 3 ：分解应用程序。全面了解应用程序的结构可以更轻松地发现更相关、更具体的威胁。步骤 4 ：确定威胁。使用步骤 2 和 3 中的详细信息来确定与应用程序方案和上下文相关的威胁。步骤 5 ：确定漏洞。检查应用程序的各层以确定与威胁有关的弱点。使用漏洞类别来帮助关注最常出现错误的区域。WEB应用安全框架输入和数据验证身份验证授权配置管理敏感数据会话管理加密参数操作异常管理审核与记录一个WEB应用安全模型威胁建模：一种用于理解和消除系统安全威胁的形式化的方法方法：信息收集•定位文档（Locate written document）•访问相关人员（Interview stakeholders）•探查系统（Inspect system）分析•用户Users•构件，资产，动机 Components, assets, and motivation•入口 Entry points•弱点和威胁 Weaknesses and threats威胁消除•建立预算 Establish your budget.•排序处理 Rank treats using a model that works for you.•确立针对威胁的工作 Decide what to do with threats.消除选择：•忽略 Ignore risk. (Popular choice!)•消除 Mitigate risk：入侵代价昂贵、安全代价昂贵、能够承受？•接受 Accept risk.消除策略：•移除入口点.•减少攻击面.•区分.•最小优先权原则消除技巧：•不要过度宽泛以避免不能自拔。建立子模型分支以处理复杂性。•多数WEB APP具有共性-开发可重用的威胁模型库。•由一个草稿开始（scratch），并且不要做任何假定。消除多数明显的（foolproof）威胁将导致简单的操作过程.CH08安全工程过程模型核心工作①安全目标定义②敏感数据分析③威胁分析④安全设计⑤受攻击面分析⑥安全实现⑦安全测试⑧安全维护过程模型过程实施要点安全实施能力培养团队安全能力范畴：①软件安全的概念与意识；②典型安全问题；③开发语言的安全问题与工具；④安全设计方法；⑤数据及其敏感性；⑥攻击面；⑦威胁建模与分析；⑧信息安全法律与政策；安全目标定义确定本项目需要达到的安全目标。形成规范的文档，作为工程过程中的指导原则。安全目标定义应包括的内容：①软件名称；②软件开发目标及主要功能概述；③软件主要用户及其分析；④软件的关键信息与数据；⑤软件各个部分及其总体需要达到的安全水平。资源及敏感数据分析确定本项目实施中所涉及的敏感数据，进行分类，给出明确的定义和敏感程度，以及保护措施。软件操作的资源：网络端口，文件，服务器，URL，数据库…软件操作的主要数据：数据名类型作用敏感程度安全要求威胁分析分析系统用户，部署，功能，确定系统威胁来源。明确：系统关键工程，部署，各个部分及功能用户威胁名称威胁来源说明重要程度安全设计根据安全目标，敏感数据，威胁分析的内容，实现安全设计。包括架构，安全问题的应对措施等。需明确：①系统架构与安全性问题②安全问题及其应对措施③架构与安全目标的响应④敏感数据的保护措施⑤威胁的应对措施受攻击面分析与安全设计对应，根据设计的架构，以及敏感信息，对受攻击面及攻击路径进行分析。典型的受攻击面包括：端口，数据，文件…攻击面类别威胁来源重要程度安全实现安全测试安全维护]]></content>
      <categories>
        <category>大二</category>
      </categories>
      <tags>
        <tag>软件安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POSIX信号量]]></title>
    <url>%2F2019%2F04%2F22%2FPOSIX%E4%BF%A1%E5%8F%B7%E9%87%8F%2F</url>
    <content type="text"><![CDATA[POSIX信号量的操作POSIX信号量有两种：有名信号量和无名信号量，无名信号量也被称作基于内存的信号量。有名信号量通过IPC名字进行进程间的同步，而无名信号量如果不是放在进程间的共享内存区中，是不能用来进行进程间同步的，只能用来进行线程同步。POSIX三种操作创建信号量创建的过程还要求初始化信号量的值。根据信号量取值（代表可用资源的数目）的不同，POSIX信号量还可以分为：二值信号量：信号量的值只有0和1，这和互斥量很类型，若资源被锁住，信号量的值为0，若资源可用，则信号量的值为1；计数信号量：信号量的值在0到一个大于1的限制值（POSIX指出系统的最大限制值至少要为32767）。该计数表示可用的资源的个数。等待信号量(wait)/P操作该操作会检查信号量的值，如果其值小于或等于0，那就阻塞，直到该值变成大于0，然后等待进程将信号量的值减1，进程获得共享资源的访问权限。为原子操作。挂出一个信号量(post)/V操作该操作将信号量的值加1，如果有进程阻塞着等待该信号量，那么其中一个进程将被唤醒。POSIX信号量函数接口有名信号量的创建和删除创建1234567#include &lt;semaphore.h&gt; sem_t *sem_open(const char *name, int oflag);sem_t *sem_open(const char *name, int oflag, mode_t mode, unsigned int value); //成功返回信号量指针，失败返回SEM_FAILED信号量通过name参数即信号量的名字来进行标识oflag参数可以为：0，O_CREAT，O_EXCL，0表示打开一个已存在的信号量，如果为O_CREAT，表示如果信号量不存在就创建一个信号量，如果存在则打开被返回。此时mode和value需要指定。如果为O_CREAT | O_EXCL，表示如果信号量已存在会返回错误。mode参数用于创建信号量时，表示信号量的权限位，和open函数一样包括：S_IRUSR，S_IWUSR，S_IRGRP，S_IWGRP，S_IROTH，S_IWOTH。value表示创建信号量时，信号量的初始值。删除12345#include &lt;semaphore.h&gt; int sem_close(sem_t *sem);int sem_unlink(const char *name); //成功返回0，失败返回-1sem_close互斥量和信号量的差别互斥量必须由给它上锁的线程解锁。而信号量不需要由等待它的线程进行挂出，可以在其他进程进行挂出操作。互斥量要么被锁住，要么是解开状态，只有这两种状态。而信号量的值可以支持多个进程成功进行wait操作。信号量的挂出操作总是被记住，因为信号量有一个计数值，挂出操作总会将该计数值加1，然而当向条件变量发送一个信号时，如果没有线程等待在条件变量，那么该信号会丢失。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下的信号量机制与编程]]></title>
    <url>%2F2019%2F04%2F22%2FLinux%E4%B8%8B%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[信号量当我们在多用户系统，多进程系统，或是两者混合的系统中使用线程操作编写程序时，我们经常会发现我们有段临界代码，在此处我们需要保证一个进程（或是一个线程的执行）需要排他的访问一个资源。为了解决这个问题，引用了信号量机制，我们可以使用互斥或信号量来控制一个多线程程序对于临界区的访问。信号量是一个特殊的变量，他是一个整数，并且只有两个操 作可以使得其值增加：等待(wait)与信号(signal)。用于等待(wait)的P(信号量变量)用于信号(signal)的V(信号量变量)二值信号量二值信号量使是只有0和1两个值的变量假如有一个信号量为mutex，有如下两个操作P(mutex)/wait(mutex) 若mutex大于0,mutex减为0;若mutex等于0,则挂起该进程V(mutex)/signal(mutex) 若有进程被挂起等待mutex则释放mutex使被挂起的进程执行,若没有,则mutex加到1**mutex取值只能为1/0**也叫互斥信号量,可以用其管理临界区资源的控制权Linux中的信号量工具信号量函数信号量函数定义:1234#include &lt;sys/sem.h&gt;/*有可能还需要包含sys/types.h与sys/ipc.h文件*/int semctl(int sem_id, int sem_num, int command, ...);int semget(key_t key, int num_sems, int sem_flags);int semop(int sem_id, struct sembuf *sem_ops, size_t num_sem_ops);这些函数用于操作信号量值数组semget函数semget的作用： 创建一个新信号量 或者 取得一个已有的信号量1int semget(key_t key, int num_sems, int sem_flags);key是整数值(唯一非零),可以任意指定一个正整数,semget可以根据key,新创建一个信号量,返回改信号量的标识,不相关的进程可以通过它访问这个创建的信号量,代表程序可能会使用某个资源.如果在两个进程中使用相同的key则key将负责两个进程的协调工作.PS:​ 同一个key值返回的信号量标识相同​ 不同的key值会创建不同的信号量,且信号量之间没有任何关系num_sems表示需要的信号量数目,一般为1sem_flags是一组标志,与fopen函数的 “w” “b” “r”类似,最低的9位二进制数字代表了这个信号量的权限信息.如IPC_CREATE | 0666,这些标记可以与 IPC_CREAT进行或操作来创建新的信号量,同时又可以用于取一个已有的信号量,使用IPC_CREAT | IPC_EXCL 来确保新建信号量，如果信号量已经有了会返回错误。PS:​ IPC_CREAT 如果共享内存不存在，则创建一个共享内存，否则打开操作。​ IPC_EXCL 只有在共享内存不存在的时候，新的共享内存才建立，否则就产生错误。semget函数成功返回一个相应信号量标识符(非0),失败返回-1.semop函数semop函数用于对信号量进行操作。1int semop(int sem_id, struct sembuf *sem_opa, size_t num_sem_ops);sem_id,表示对哪一个信号量进行操作,由semget函数返回sembuf *sem_ops123456789struct sembuf &#123;short sem_num; //要处理的信号量的下标,即指定对哪个信号灯进行操作(0,1,2...)若为二值信号量则为0short sem_op; //要执行的操作,1表示加一,-1表示减一short sem_flg; //操作标志,通常设置为SEM_UNDO。这会使得操作系统跟踪当前进程对信号量所 //做的改变，而且如果进程终止而没有释放这个信号量， 如果信号量为这个进 //程所占有，这个标记可以使得操作系统自动释放这个信号量。&#125;size_t num_sem_ops表示操作次数一般为1semctl函数semctl用于直接控制信号量的信息，例如初始化一个值或删除信号量。1int semctl(int sem_id, int sem_num, int command, ...);sem_id,表示对哪一个信号量进行操作,由semget函数返回sem_num,要处理的信号量的下标,即指定对哪个信号灯进行操作(0,1,2…)若为二值信号量则为0command,表示要执行的动作SETVAL：用于初始化信号量为一个已知的值。所需要的值作为联合semun.val成员来传递。在信号量第一次使用之前需要设置信号量。IPC_RMID：当信号量不再需要时用于删除一个信号量标识。union semun123456789union semun&#123;int val;struct semid_ds *buf;unsigned short *array;&#125;;这个声明一般包含在sem.h里面，也有可能没有，没有的话需要自己声明。根据command的不同，返回值也不同。对于 SETVAL和IPC_RMID 成功返回0 失败返回-1信号量的使用创建信号量1234int sem_id;sem_id = semget((key_t)1234, 2, 0666 | IPC_CREAT);if (sem_id == -1) fprintf(stderr, "Failed to create semapore\n");设置信号量初值12345678910int set_semvalue(int sem_id, int index, int value)//index为信号量中的第几个信号灯&#123; union semun sem_union; sem_union.val = value; if (semctl(sem_id, index, SETVAL, sem_union) == -1) return 0; else return 1;&#125;删除信号量12345void del_semvalue(int sem_id)&#123; if (semctl(sem_id, 0, IPC_RMID) == -1) fprintf(stderr, "Failed to delete semapore\n");&#125;P操作P操作是通过调用semop函数实现的。123456789101112131415int P(int sem_id, int index)&#123; struct sembuf sem_b; sem_b.sem_num = index; sem_b.sem_op = -1; sem_b.sem_flg = SEM_UNDO; if (semop(sem_id, &amp;sem_b, 1) == -1) &#123; fprintf(stderr, "semapore_p failed\n"); return 0; &#125; return 1;&#125;V操作123456789101112131415int V(int sem_id, int index)&#123; struct sembuf sem_b; sem_b.sem_num = index; sem_b.sem_op = 1; sem_b.sem_flg = SEM_UNDO; if (semop(sem_id, &amp;sem_b, 1) == -1) &#123; fprintf(stderr, "semapore_v failed\n"); return 0; &#125; return 1;&#125;]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python爬虫框架Scrapy(二)]]></title>
    <url>%2F2019%2F04%2F08%2Fpython%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6Scrapy-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[爬虫编写item读取数据12345678910tr_list = response.xpath("//table[@class='tablelist']/tr")[1:-1] for tr in tr_list: item = &#123;&#125; item['title'] = tr.xpath("./td[1]/a/text()").extract_first() item['position'] = tr.xpath("./td[2]/text()").extract_first() item['number'] = tr.xpath("./td[3]/text()").extract_first() item['place'] = tr.xpath("./td[4]/text()").extract_first() item['publish_date'] = tr.xpath("./td[5]/text()").extract_first() logging.warning(item) yield item构造Request对象实现翻页12345678#下一页URL地址 next_url = response.xpath("//a[@id='next']/@href").extract_first() if next_url != "javascript:;": next_url = "http://hr.tencent.com/" + next_url yield scrapy.Request( next_url, callback=self.parse )1scrapy.Request(url[,callback,method='GET',headers,body,cookies,meta,dont_filter=False])构造Request对象实现详情页爬取12def parse_detail(self,response): ...]]></content>
      <categories>
        <category>python爬虫</category>
      </categories>
      <tags>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python爬虫框架Scrapy(一)]]></title>
    <url>%2F2019%2F04%2F07%2Fpython%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6Scrapy-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[Scrapy框架简介-Spider MiddlewaresSpider只对response进行过滤处理，不对数据进行处理初始化创建项目1scrapy startproject myspider生成爬虫123scrapy genspider response response.cn#@response 爬虫名称#@response.cn 爬虫域名范围在生成的response.py文件中包含以下代码12345678910111213# -*- coding: utf-8 -*-import scrapyclass PixviSpider(scrapy.Spider): name = 'pixvi' #爬虫名 allowed_domains = ['pixiv.net'] #爬虫范围，需要爬取的url地址你必须在这个域名下 start_urls = ['http://www.pixiv.net/'] #初始响应网站，需要有内容爬取的内容 def parse(self, response):#parse函数名称不能修改 #处理start_ urls对应的响应 item = response.xpath() #返回的是一个含有selector对象的列表 yield item#生成器可以遍历不占用太多空间运行爬虫在项目文件夹下运行1scrapy crawl responsepipline生成的item数据会传入pipline中，在使用pipline之前要先在settings.py中去掉可以创建多个pipline：​ 1.可能有多个爬虫​ 2.可能爬取的数据需要不同的处理（如写入不同的数据库）123class Test1Pipeline(object): def process_item(self, item, spider):#实现存储方法，函数名同样不能改变 return item如有多个pipline，每个pipline都要return item以传入下一个管道，不能缺少return123#ITEM_PIPELINES = &#123;# 'test1.pipelines.Test1Pipeline': 300,#&#125;的注释。300表示举例pipline的远近，越小越先执行若有多个爬虫，则可以​ 1.在item中加入item[&#39;come_from&#39;] = &#39;spider1&#39;​ if item[&#39;come_from&#39;] == &#39;spider1&#39;:​ …​ 2.在pipline.py中直接用​ if spider.name == &#39;spider1&#39;:​ …logging模块logging模块是输出日志的模块可以在settings.py中加入LOG_LEVEL = &#39;WARNING&#39;来使程序输出warning及以上级别的日志logging模块可以代替print输出数据并知晓数据来自哪一个文件1234import logginglogger = logging.getlogger(__name__)logger.warning(item)运行结果12345672019-04-08 17:30:19 [test1.spiders.pixvi] WARNING: &#123;'come_from': 'pixvi'&#125;2019-04-08 17:30:19 [test1.pipelines] WARNING: ----------2019-04-08 17:30:19 [test1.spiders.pixvi] WARNING: &#123;'come_from': 'pixvi'&#125;2019-04-08 17:30:19 [test1.pipelines] WARNING: ----------2019-04-08 17:30:19 [test1.spiders.pixvi] WARNING: &#123;'come_from': 'pixvi'&#125;2019-04-08 17:30:19 [test1.pipelines] WARNING: ----------...即可以打印输出内容的时间，文件来源，等级，内容在settings.py中加入LOG_FILE = ./XXX.log即可把日志内容保存在文件中]]></content>
      <categories>
        <category>python爬虫</category>
      </categories>
      <tags>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django学习笔记（三）]]></title>
    <url>%2F2019%2F03%2F12%2FDjango%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[初试API1$python manage.py shell创建一个管理员账号1$python manage.py createsuperuser]]></content>
      <categories>
        <category>Web学习</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django学习笔记（二）]]></title>
    <url>%2F2019%2F03%2F12%2FDjango%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Django基本命令创建project1$django-admin startproject myproject进入myproject目录使用开发服务器1$ python manage.py runserver会报错1You&apos;re accessing the development server over HTTPS, but it only supports HTTP.django 默认的runserver使用的是http协议，如果需要https协议，需要以下3个库123django-extensions django-werkzeug-debugger-runserver pyOpenSSL安装12345pip install django-extensionspip install django-werkzeug-debugger-runserverpip install pyOpenSSL配置django的settings.py文件在INSTALLED_APPS下添加123'werkzeug_debugger_runserver','django_extensions',在终端以https的方式运行1$python manage.py runserver_plus --cert server.crt创建APP1$ python manage.py startapp learn创建数据库表或更改数据库表或字段1234# 1. 创建更改的文件python manage.py makemigrations# 2. 将生成的py文件应用到数据库python manage.py migrate清空数据库1$python manage.py flush创建超级管理员123456$python manage.py createsuperuser# 按照提示输入用户名和对应的密码就好了邮箱可以留空，用户名和密码必填# 修改 用户密码可以用：$python manage.py changepassword usernameDjango项目环境终端1$python manage.py shell数据库命令行1$python manage.py dbshellDjango 会自动进入在settings.py中设置的数据库，如果是 MySQL 或 postgreSQL,会要求输入数据库用户密码。在这个终端可以执行数据库的SQL语句。如果对SQL比较熟悉，可能喜欢这种方式。视图在/views.py中输入代码12345from django.http import HttpResponsedef index(request): return HttpResponse("Hello, world. You're at the learn index.")如果想看见效果，我们需要将一个 URL 映射到它为了创建 URLconf，请在 learn目录里新建一个 urls.py 文件。在urls.py中输入代码1234567891011121314151617181920212223242526from django.urls import pathfrom . import viewsurlpatterns = [ path('', views.index, name='index'),]'''path函数有四个参数两个必须参数：route 和 view，两个可选参数：kwargs 和 name。@route:route 是一个匹配 URL 的准则（类似正则表达式）。当 Django 响应一个请求时，它会从 urlpatterns 的第一项开始，按顺序依次匹配列表中的项，直到找到匹配的项。这些准则不会匹配 GET 和 POST 参数或域名。例如，URLconf 在处理请求 https://www.example.com/myapp/ 时，它会尝试匹配 myapp/ 。处理请求 https://www.example.com/myapp/?page=3 时，也只会尝试匹配 myapp/。@view:当 Django 找到了一个匹配的准则，就会调用这个特定的视图函数，并传入一个 HttpRequest 对象作为第一个参数，被“捕获”的参数以关键字参数的形式传入。稍后，我们会给出一个例子。@kwargs:任意个关键字参数可以作为一个字典传递给目标视图函数。@name:为你的 URL 取名能使你在 Django 的任意地方唯一地引用它，尤其是在模板中。这个有用的特性允许你只改一个文件就能全局地修改某个 URL 模式。'''下一步是要在根 URLconf 文件中指定我们创建的 learn.urls 模块。在 vx/urls.py 文件的 urlpatterns 列表里插入一个 include()， 如下：1234567from django.contrib import adminfrom django.urls import include, pathurlpatterns = [ path('learn/', include('learn.urls')), path('admin/', admin.site.urls),]函数 include()允许引用其它 URLconfs。每当 Django 遇到 :func：~django.urls.include时，它会截断与此项匹配的 URL 的部分，并将剩余的字符串发送到 URLconf 以供进一步处理。我们设计 include()的理念是使其可以即插即用。因为应用有它自己的URLconf( vx/urls.py )，他们能够被放在&quot;/vx/&quot; ， &quot;/fun_vx/&quot; ，&quot;/content/vx/&quot;，或者其他任何路径下，这个应用都能够正常工作。当包括其它 URL 模式时你应该总是使用 include() ， admin.site.urls 是唯一例外。运行1$python manage.py runserver_plus --cert server.crt访问.../learn即可看见简单的文字视图数据库配置vx/settings.py是Django项目设置的python模块。通常，这个配置文件使用 SQLite 作为默认数据库。如果你不熟悉数据库，或者只是想尝试下 Django，这是最简单的选择。Python 内置 SQLite，所以你无需安装额外东西来使用它。当你开始一个真正的项目时，你可能更倾向使用一个更具扩展性的数据库，例如 PostgreSQL，避免中途切换数据库这个令人头疼的问题。如果你想使用其他数据库，你需要安装合适的 database bindings ，然后改变设置文件中 DATABASES &#39;default&#39; 项目中的一些键值：ENGINE — 可选值有 &#39;django.db.backends.sqlite3&#39;，&#39;django.db.backends.postgresql&#39;，&#39;django.db.backends.mysql&#39;，或 &#39;django.db.backends.oracle&#39;。其它 可用后端。NAME - 数据库的名称。如果使用的是 SQLite，数据库将是你电脑上的一个文件，在这种情况下， NAME 应该是此文件的绝对路径，包括文件名。默认值 os.path.join(BASE_DIR, &#39;db.sqlite3&#39;) 将会把数据库文件储存在项目的根目录。在编辑/settings之前，将TIME_ZONE设置为自己所在时区通常， INSTALLED_APPS 默认包括了以下 Django 的自带应用：django.contrib.admin — 管理员站点， 你很快就会使用它。django.contrib.auth — 认证授权系统。django.contrib.contenttypes — 内容类型框架。django.contrib.sessions — 会话框架。django.contrib.messages — 消息框架。django.contrib.staticfiles — 管理静态文件的框架。这些应用被默认启用是为了给常规项目提供方便。默认开启的某些应用需要至少一个数据表，所以，在使用他们之前需要在数据库中创建一些表。1$python manage.py migrate创造模型在 Django 里写一个数据库驱动的 Web 应用的第一步是定义模型 - 也就是数据库结构设计和附加的其它元数据。在learn/models.py中创建python类激活模型创建模型的代码给了 Django 很多信息，通过这些信息，Django 可以：为这个应用创建数据库 schema（生成 CREATE TABLE 语句）。创建可以与 Question 和 Choice 对象进行交互的 Python 数据库 API。但是首先得把 learn 应用安装到我们的项目里。为了在我们的工程中包含这个应用，我们需要在配置类 INSTALLED_APPS 中添加设置。因为 learnConfig 类写在文件 learn/apps.py 中，所以它的点式路径是 &#39;learn.apps.learnConfig&#39;。在文件 mysite/settings.py中 INSTALLED_APPS 子项添加点式路径。运行命令进行模型迁移1$python manage.py makemigrations learn运行migrate命令在数据库里创建新定义的模型的数据表1$python manage.py migrate迁移是非常强大的功能，它能让你在开发过程中持续的改变数据库结构而不需要重新删除和创建表 - 它专注于使数据库平滑升级而不会丢失数据。我们会在后面的教程中更加深入的学习这部分内容，现在，你只需要记住，改变模型需要这三步：编辑 models.py 文件，改变模型。运行 python manage.py makemigrations 为模型的改变生成迁移文件。运行 python manage.py migrate 来应用数据库迁移。]]></content>
      <categories>
        <category>Web学习</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django学习笔记（一）]]></title>
    <url>%2F2019%2F03%2F12%2FDjango%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Django文件urls.py网址入口，关联到对应的views.py中的一个函数（或者generic类），访问网址就对应一个函数。views,py处理用户发出的请求，从urls.py中对应过来, 通过渲染templates中的网页可以将显示内容，比如登陆后的用户名，用户请求的数据，输出到网页。models.py与数据库操作相关，存入或读取数据时用到这个，当然用不到数据库的时候 你可以不使用。forms.py表单，用户在浏览器上输入数据提交，对数据的验证工作以及输入框的生成等工作，当然你也可以不使用。templates 文件夹views.py 中的函数渲染templates中的Html模板，得到动态内容的网页，当然可以用缓存来提高速度。admin.py后台，可以用很少量的代码就拥有一个强大的后台。settings.pyDjango 的设置，配置文件，比如 DEBUG 的开关，静态文件的位置等。Django安装DjangoWindows下在Anaconda Prompt中用pip install Django安装虚拟环境依赖安装（搭建多个开发环境）Windows下Anaconda Prompt中用pip install virtualenv virtualenvwrapper-win安装虚拟环境使用方法mkvirtualenv zqxt：创建运行环境zqxtworkon zqxt: 工作在 zqxt 环境 或 从其它环境切换到 zqxt 环境deactivate: 退出终端环境rmvirtualenv ENV：删除运行环境ENVmkproject mic：创建mic项目和运行环境micmktmpenv：创建临时运行环境lsvirtualenv: 列出可用的运行环境lssitepackages: 列出当前环境安装了的包创建的环境是独立的，互不干扰，无需sudo权限即可使用 pip 来进行包的管理。]]></content>
      <categories>
        <category>Web学习</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用numpy实现简单的三层BP神经网络]]></title>
    <url>%2F2018%2F10%2F13%2F%E7%94%A8numpy%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%89%E5%B1%82bp%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[最近在看吴恩达老师的机器学习视频，讲到神经网络时有些模糊，于是决定自己用代码实现一下最基本的神经网络。 关于BP算法一文弄懂神经网络中的反向传播法代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import numpy as npclass NeuralNetwork(object): def __init__(self,input_nodes,hidden_nodes,output_nodes,learning_rate): #设定输入层，隐藏层，输出层的节点个数 self.input_nodes = input_nodes+1 # +1 设置偏执神经元来进行修正 self.hidden_nodes = hidden_nodes self.output_nodes = output_nodes #初始化权值和学习速率 self.weight_input_to_hidden = np.random.normal(0.0,self.hidden_nodes**-0.5,(self.hidden_nodes,self.input_nodes)) self.weight_hidden_to_output = np.random.normal(0.0,self.output_nodes**-0.5,(self.output_nodes,self.hidden_nodes)) self.lr = learning_rate #激励函数 def Sigmoid(self,x): return 1.0 / (1.0 + np.exp(-x)) def train(self,input_list,target_list): inputs = np.array(input_list,ndmin=2).T targets = np.array(target_list,ndmin=2).T #前向传播 hidden_inputs = np.dot(self.weight_input_to_hidden,inputs) hidden_outputs= self.Sigmoid(hidden_inputs) final_inputs = np.dot(self.weight_hidden_to_output,hidden_outputs) final_outputs = self.Sigmoid(final_inputs) #反向传播 outputs_errors = (final_outputs - targets) * final_outputs * (1 - final_outputs) hidden_errors = np.dot(self.weight_hidden_to_output.T,outputs_errors) #梯度下降 self.weight_input_to_hidden -= np.dot((hidden_errors * hidden_outputs * (1 - hidden_outputs)),inputs.T) * self.lr self.weight_hidden_to_output -= np.dot(outputs_errors,hidden_outputs.T) *self.lr print("误差:") print(1/2 * np.square((final_outputs-targets))) #测试函数 def run(self,inputs_list): inputs = np.array(inputs_list,ndmin=2).T hidden_inputs = np.dot(self.weight_input_to_hidden,inputs) hidden_outputs = self.Sigmoid(hidden_inputs) final_inputs = np.dot(self.weight_hidden_to_output,hidden_outputs) final_outputs = self.Sigmoid(final_inputs) return final_outputs #测试用神经网络实现异或功能def main(): cases = [[0,0,0.1], [0,1,0.1], [1,0,0.1], [1,1,0.1]] labels = [[0],[1],[1],[0]] #迭代10000次 limit = 10000 nn = NeuralNetwork(2,4,1,0.5) for i in range(limit): for i in range(4): nn.train(cases[i],labels[i]) a = nn.run([1,1,0.1]) print(a)if __name__ == '__main__': main()只在输入层加入了偏执神经元，在第二层并没有添加，在第二层添加对拟合效果的提升并不是很大(主要是实现会更复杂一些(逃]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Github+Hexo+NexT的配置]]></title>
    <url>%2F2018%2F09%2F30%2F%E5%85%B3%E4%BA%8EGithub-Hexo-NexT%E7%9A%84%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
</search>

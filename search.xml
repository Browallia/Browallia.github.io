<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Django学习笔记（二）]]></title>
    <url>%2F2019%2F03%2F12%2FDjango%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Django基本命令创建project1$django-admin startproject myproject 进入myproject目录 使用开发服务器1$ python manage.py runserver 会报错 1You&apos;re accessing the development server over HTTPS, but it only supports HTTP. django 默认的runserver使用的是http协议，如果需要https协议，需要以下3个库 123django-extensions django-werkzeug-debugger-runserver pyOpenSSL 安装 12345pip install django-extensionspip install django-werkzeug-debugger-runserverpip install pyOpenSSL 配置django的settings.py文件 在INSTALLED_APPS下添加 123'werkzeug_debugger_runserver','django_extensions', 在终端以https的方式运行 1$python manage.py runserver_plus --cert server.crt 创建APP1$ python manage.py startapp learn 创建数据库表或更改数据库表或字段1234# 1. 创建更改的文件python manage.py makemigrations# 2. 将生成的py文件应用到数据库python manage.py migrate 清空数据库1$python manage.py flush 创建超级管理员123456$python manage.py createsuperuser# 按照提示输入用户名和对应的密码就好了邮箱可以留空，用户名和密码必填# 修改 用户密码可以用：$python manage.py changepassword username Django项目环境终端1$python manage.py shell 数据库命令行1$python manage.py dbshell Django 会自动进入在settings.py中设置的数据库，如果是 MySQL 或 postgreSQL,会要求输入数据库用户密码。 在这个终端可以执行数据库的SQL语句。如果您对SQL比较熟悉，可能喜欢这种方式。 视图在/views.py中输入代码 12345from django.http import HttpResponsedef index(request): return HttpResponse("Hello, world. You're at the learn index.") 如果想看见效果，我们需要将一个 URL 映射到它 为了创建 URLconf，请在 learn目录里新建一个 urls.py 文件。 在urls.py中输入代码 1234567891011121314151617181920212223242526from django.urls import pathfrom . import viewsurlpatterns = [ path('', views.index, name='index'),]'''path函数有四个参数两个必须参数：route 和 view，两个可选参数：kwargs 和 name。@route:route 是一个匹配 URL 的准则（类似正则表达式）。当 Django 响应一个请求时，它会从 urlpatterns 的第一项开始，按顺序依次匹配列表中的项，直到找到匹配的项。这些准则不会匹配 GET 和 POST 参数或域名。例如，URLconf 在处理请求 https://www.example.com/myapp/ 时，它会尝试匹配 myapp/ 。处理请求 https://www.example.com/myapp/?page=3 时，也只会尝试匹配 myapp/。@view:当 Django 找到了一个匹配的准则，就会调用这个特定的视图函数，并传入一个 HttpRequest 对象作为第一个参数，被“捕获”的参数以关键字参数的形式传入。稍后，我们会给出一个例子。@kwargs:任意个关键字参数可以作为一个字典传递给目标视图函数。@name:为你的 URL 取名能使你在 Django 的任意地方唯一地引用它，尤其是在模板中。这个有用的特性允许你只改一个文件就能全局地修改某个 URL 模式。''' 下一步是要在根 URLconf 文件中指定我们创建的 vx.urls 模块。在 vx/urls.py 文件的 urlpatterns 列表里插入一个 include()， 如下： 1234567from django.contrib import adminfrom django.urls import include, pathurlpatterns = [ path('vx/', include('vx.urls')), path('admin/', admin.site.urls),] 函数 include()允许引用其它 URLconfs。每当 Django 遇到 :func：~django.urls.include 时，它会截断与此项匹配的 URL 的部分，并将剩余的字符串发送到 URLconf 以供进一步处理。 我们设计 include()的理念是使其可以即插即用。因为应用有它自己的URLconf( vx/urls.py )，他们能够被放在 “/vx/“ ， “/fun_vx/“ ，”/content/polls/“，或者其他任何路径下，这个应用都能够正常工作。 当包括其它 URL 模式时你应该总是使用 include() ， admin.site.urls 是唯一例外。 运行 1$python manage.py runserver_plus --cert server.crt 访问…/learn即可看见简单的文字视图]]></content>
      <categories>
        <category>Web学习</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django学习笔记（一）]]></title>
    <url>%2F2019%2F03%2F12%2FDjango%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Django文件urls.py网址入口，关联到对应的views.py中的一个函数（或者generic类），访问网址就对应一个函数。 views,py处理用户发出的请求，从urls.py中对应过来, 通过渲染templates中的网页可以将显示内容，比如登陆后的用户名，用户请求的数据，输出到网页。 models.py与数据库操作相关，存入或读取数据时用到这个，当然用不到数据库的时候 你可以不使用。 forms.py表单，用户在浏览器上输入数据提交，对数据的验证工作以及输入框的生成等工作，当然你也可以不使用。 templates 文件夹 views.py 中的函数渲染templates中的Html模板，得到动态内容的网页，当然可以用缓存来提高速度。 admin.py后台，可以用很少量的代码就拥有一个强大的后台。 settings.pyDjango 的设置，配置文件，比如 DEBUG 的开关，静态文件的位置等。 Django安装DjangoWindows下在Anaconda Prompt中用pip install Django安装 虚拟环境依赖安装（搭建多个开发环境）Windows下Anaconda Prompt中用 pip install virtualenv virtualenvwrapper-win 安装 虚拟环境使用方法mkvirtualenv zqxt：创建运行环境zqxt workon zqxt: 工作在 zqxt 环境 或 从其它环境切换到 zqxt 环境 deactivate: 退出终端环境 rmvirtualenv ENV：删除运行环境ENV mkproject mic：创建mic项目和运行环境mic mktmpenv：创建临时运行环境 lsvirtualenv: 列出可用的运行环境 lssitepackages: 列出当前环境安装了的包 创建的环境是独立的，互不干扰，无需sudo权限即可使用 pip 来进行包的管理。]]></content>
      <categories>
        <category>Web学习</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用numpy实现简单的三层BP神经网络]]></title>
    <url>%2F2018%2F10%2F13%2F%E7%94%A8numpy%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%89%E5%B1%82bp%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[用numpy实现简单的三层BP神经网络 最近在看吴恩达老师的机器学习视频，讲到神经网络时有些模糊，于是决定自己用代码实现一下最基本的神经网络。 关于BP算法一文弄懂神经网络中的反向传播法 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import numpy as npclass NeuralNetwork(object): def __init__(self,input_nodes,hidden_nodes,output_nodes,learning_rate): #设定输入层，隐藏层，输出层的节点个数 self.input_nodes = input_nodes+1 # +1 设置偏执神经元来进行修正 self.hidden_nodes = hidden_nodes self.output_nodes = output_nodes #初始化权值和学习速率 self.weight_input_to_hidden = np.random.normal(0.0,self.hidden_nodes**-0.5,(self.hidden_nodes,self.input_nodes)) self.weight_hidden_to_output = np.random.normal(0.0,self.output_nodes**-0.5,(self.output_nodes,self.hidden_nodes)) self.lr = learning_rate #激励函数 def Sigmoid(self,x): return 1.0 / (1.0 + np.exp(-x)) def train(self,input_list,target_list): inputs = np.array(input_list,ndmin=2).T targets = np.array(target_list,ndmin=2).T #前向传播 hidden_inputs = np.dot(self.weight_input_to_hidden,inputs) hidden_outputs= self.Sigmoid(hidden_inputs) final_inputs = np.dot(self.weight_hidden_to_output,hidden_outputs) final_outputs = self.Sigmoid(final_inputs) #反向传播 outputs_errors = (final_outputs - targets) * final_outputs * (1 - final_outputs) hidden_errors = np.dot(self.weight_hidden_to_output.T,outputs_errors) #梯度下降 self.weight_input_to_hidden -= np.dot((hidden_errors * hidden_outputs * (1 - hidden_outputs)),inputs.T) * self.lr self.weight_hidden_to_output -= np.dot(outputs_errors,hidden_outputs.T) *self.lr print("误差:") print(1/2 * np.square((final_outputs-targets))) #测试函数 def run(self,inputs_list): inputs = np.array(inputs_list,ndmin=2).T hidden_inputs = np.dot(self.weight_input_to_hidden,inputs) hidden_outputs = self.Sigmoid(hidden_inputs) final_inputs = np.dot(self.weight_hidden_to_output,hidden_outputs) final_outputs = self.Sigmoid(final_inputs) return final_outputs #测试用神经网络实现异或功能def main(): cases = [[0,0,0.1], [0,1,0.1], [1,0,0.1], [1,1,0.1]] labels = [[0],[1],[1],[0]] #迭代10000次 limit = 10000 nn = NeuralNetwork(2,4,1,0.5) for i in range(limit): for i in range(4): nn.train(cases[i],labels[i]) a = nn.run([1,1,0.1]) print(a)if __name__ == '__main__': main() 只在输入层加入了偏执神经元，在第二层并没有添加，在第二层添加对拟合效果的提升并不是很大(主要是实现会更复杂一些(逃]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Github+Hexo+NexT的配置]]></title>
    <url>%2F2018%2F09%2F30%2F%E5%85%B3%E4%BA%8EGithub-Hexo-NexT%E7%9A%84%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"></content>
  </entry>
</search>
